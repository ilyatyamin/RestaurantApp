# Клиент-серверное приложение для управления рестораном
> Илья Тямин, БПИ-226

> Если возникли вопросы, tg: @mrshrimp_it

## Как пользоваться программой и в общем о реализации
Данное домашнее задание я реализовывал в виде "клиент-сервера", то есть в репозитории предоставлено 2 проекта:
-  `Server`, его необходимо запустить **ДО** включения терминала с проектом `RestaurantClient`. Server разворачивает сервер на localhost и обрабатывает `GET`, `POST` запросы к нему. Грубо говоря, вся backend-часть приложение реализована именно здесь.
- `RestaurantClient` - консольное приложение, его необходимо запустить **ПОСЛЕ** включения сервера. Данный проект посылает запросы на сервер, получает от них ответ и передает пользователю в консоль. Также здесь реализована вся механика общения с пользователем: проверка корректного ввода и т.д. При должном желании, из-за разработанной архитектуры консольное приложение может быть заменено на полноценный сайт (web-приложение).

При запуске сервера никаких действий не требуется, он автоматически начнет свою работу. **Все действия, производимые с сервером, например, старт нового заказа или добавление блюда в меню, автоматически логгируются в файл `logs.log`, расположенный по путю `Server/Data/logs.log`**. Благодаря разработанному логгеру, системному администратору и разработчика программы ( :) ) удобно отслеживать действия, происходящие с рестораном. Стоит заметить, что после перезапуска сервера данные не стираются, поэтому логи также остаются и за предыдущие запуски.

При запуске клиента пользователю будет предложено сначала авторизироваться. 

```
Пожалуйста, авторизуйтесь.
1. Войти как пользователь.
2. Войти как администратор.
3. Зарегистрироваться как пользователь.
4. Зарегистрироваться как администратор.
5. Посмотреть меню ресторана.
-1. Выйти из приложения.
```
Если у пользователя еще нет аккаунта, то ему будет необходимо зарегистрироваться. 

<span style="color:green">При авторизации администратора / пользователя, система генерирует случайный "токен" (грубо говоря, ключ)</span>. Данный ключ действует около часа, затем пользователю нужно будет снова перезайти под своим логином / паролем. Все действия на сервере будут происходить только если у пользователя "валидный" токен, то есть его срок не истек, он имеет права на выполняемую операцию (например, посетитель не сможет случайно добавить в меню новое блюдо, так как на это имеет право только администратор). 

После корректной авторизации пользователю приложение-клиент выведет следующее меню:
```
Меню посетителя:
1. Добавить новый заказ.
2. Добавить блюдо / блюда в существующий заказ.
3. Получить статус заказа по его ID.
4. Отменить заказ по его ID.
5. Заплатить за заказ.
6. Оставить отзыв о заказе.
7. Посмотреть меню ресторана.
8. Выйти из аккаунта.
-1. Выйти из приложения.
```

А администратору такое:
```
Меню администратора:
1. Добавить блюдо в меню.
2. Убрать блюдо из меню по его id. 
3. Изменить характеристику блюда по его id.
4. Увеличить количество единиц блюда по его id.
5. Получить статистику по ресторану.
6. Посмотреть меню ресторана.
7. Выйти из аккаунта.
-1. Выйти из приложения.
```

Таким образом, были перечислены все поддерживаемые в приложении функции.

В зависимости от ввода пользователя / администратора, приложение-клиент запросит нужные данные у пользователя, обработает их корректность и передаст на сервер. В случае результата 200 (OK), программа выведет или просто ОК, или, например, ID созданного заказа (зависит от команды). В случае ошибки, программа вернет пользователю что не так было в его инструкциях. 

После перезапуска сервера / клиента программа не потеряет все свои данные, так как данные сохраняются. Единственное, после перезапуска сервера, всем пользователям необходимо будет заново авторизироваться.

## Использование шаблонов проектирования: какие и почему
В некоторых частях программы я использовал также и другие паттерны, но основные используемые это
### Фасад
В данном проекте фасад является одним из самых часто используемых паттернов. Фасад предоставляет простой интерфейс к сложной системе классов, таким, например, является, классы Admin и Visitor. Их методы требуют необходимые для работы параметры, передают их в более сложные системы, где написана основная логика работы приложения, например, OrderSystem (основная система управления заказами, где реализованы все механизмы старта заказов, их отмены, работы с многопоточностю и т.д.). Кроме того, класс System также является самым общим фасадом, так как инкапсулирует работы всех систем. Также он является фасадом для AuthentificationSystem - системы, управляющей безопасностью. Именно с помощью нее производятся все регистрации и входы в систему.

**Почему?**: порой системы бывают слишком сложные, а пользователю очень важно предоставить готовый и (!) легкий в управлении механизм. Кроме того, если данная система будет использована еще и в других системах, то разработчикам сторонних сервисов также важно иметь понятную и иерархически доступную систему классов. Также, такое решение соблюдает один из самых важных принципов ООП: инкапсуляцию. 

### Singleton
Также одним из используемых паттерном был и синглетон. В некоторых ситуациях очень важно, чтобы экземпляр объекта был всего один. Так, например, логгер может быть всего в одном экземпляре, нам не нужно иметь 5 различных логгеров, в этом просто нет необходимости. Важным для разработчика является и такой механизм как статические классы / статические поля. Сингелтон в Kotlin является как раз таким, то есть к нему и его полям можно обратиться с любой точки программы, что позволяет не создавать лишних объектов. В моем проекте синглетонами являются **объект-шифрователь** (инкапусирует необходимые данные и помогает зашифровать предоставляемые данные), **логгер** (логгирует данные с целью дальнейшего анализа баггов / поведения пользователей), **сериализатор** (сохраняет данные в файл и восстанавливает их), **`TokenSystem`** (управляет доступом пользователей к системе и создает и анализирует токены).

**Почему**? Объяснил выше, единая точка доступа к объекту и гарантирует наличие единственности объекта.

### Proxy
Proxy нужен для того чтобы подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до и после передачи вызова оригиналу. В моем проекте таким, например, является `OrderSystem`. Одним из случаев, когда пользователь не может получить доступ к методу является тот, когда он хочет узнать информацию не о своем заказе. Поясню подробнее: пользовать #1 создал заказ №20, 21, а пользователь #2 хочет узнать информацию о заказе №20 или, например, его отменить. В таком случае, система должна отказать ему в этом действии. `OrderSystem` сверяет `userId` и если они не совпадают, то отказывает в правах доступа к заказу. Это бывает очень полезно в больших системах, где безопасность выше всего.

**Почему?** Объяснил выше, с целью поддержания безопасности проекта.


## Небольшие пояснения по разработанному решению
### Токены и авторизация
Для обеспечения безопасности сессии пользователей, генерируется токен - зашифрованный ключ, уникально идентифицирующий пользователя. При входе пользователя в систему генерируется токен и передается пользователю (при работе с клиентом, без прямых запросов через API). В моем решении токен позволяет поддерживать безопасность проводимых операций, так как пользователь не сможет посмотреть конфиденциальную информацию других пользователей. Кроме того, есть возможность ограничить длину сессии пользователя.

### Хранение данных и безопасность
Данные хранятся в виде файлов `JSON`, их состояние поддерживается после каждой выполняемой операции, таким образом даже после отключения сервера / другой аварийной ситуации, данные пользователей не будут потеряны. 

**Также стоит отметить, что данные хранятся в зашифрованном виде** (полностью, не только личные данные пользователей), благодаря чему в реальных системах вероятность утечки данных снижается. При десериализации они расшифровываются и программа продолжает работу в стандартном формате. 

> Внутри программы и запросов личные данные (пароль пользователя) передаются также в зашифрованном виде с целью безопасности. 

### Многопоточность
Все заказы обрабатываются в многопоточном режиме, то есть под каждый новый заказ создается новый поток. При отмене заказа поток прерывается методом `interrupt()`, при этом программа не падает с ошибкой. Поток "засыпает" на время, равное времени готовки заказа (рассчитывалось как $$max(timeProduction1, timeProduction2, timeProduction3, ... )$$ 


### Система приоритетов и очередь
По умолчанию, будем считать, что наш ресторан может готовить всего 5 заказов одновременно, что максимально приближенно к реальному миру) Если в ресторан поступает больше, чем 5 заказов, то они становятся в очередь, а точнее в очередь с приоритетами. 

В разработанном решении присутствует система уровней пользователей: 
- если ты суммарно под текущим логином заказал меньше 10 заказов, то твой статус - Новичок
- если ты суммарно под текущим логином заказал от 10 до 30 заказов, то ты - Medium (я не знаю как это перевести на русский)
- если ты заказал от 30 заказов суммарно, то ты Lover (любитель).

В первую очередь из очереди вынимается заказ человека с самым большим уровнем. Если таких заказов несколько, то достается тот, кто был заказал первым.

### Отзывы и статистика
Пользователь имеет право оставить отзыв на заказ, но только когда он готов (ситуация, что заказ еще не готов, а отзыв уже оставлен, невозможна). Отзыв состоит из оценки (от 1 до 5) и комментария (строка).

Администратор также может выгрузить статистику по ресторану. Она состоит из средней оценки заказов и среднего количества блюд, которое заказывает 1 пользователь (сколько в среднем блюд заказывают в одном заказе), а также суммарная выручка ресторана. Статистику может получить только администратор.

### Работа напрямую с API-запросами
При необходимости, так как разработано клиент-серверное приложение и сервер, по факту, представляет API, то возможна и работа напрямую с сервером через запросы к нему. При этом потребуется вручную везде тащить за собой токен.
